#include "window_module/window.h"

#ifdef WINDOW_BACKEND_LINUX
#include "window_module/window_backend.h"

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wayland-client-core.h>
#include <wayland-client-protocol.h>
#include <wayland-client.h>  //libwayland-protocols
#include <xdg-shell.h>       //generated by wayland-scanner


typedef struct {
    struct wl_display* display;
    struct wl_surface* surface;
} handle_wl;

typedef struct {
    handle_wl              handle;
    struct wl_registry*    registry;
    struct wl_compositor*  compositor;
    struct xdg_wm_base*    shell;
    struct wl_seat*        seat;
    struct wl_keyboard*    keyboard;
    struct wl_pointer*     pointer;
    struct xdg_surface*    xdg_surface;
    struct xdg_toplevel*   toplevel;
    keyboard_key_handler   key_handler;
    pointer_button_handler button_handler;
    pointer_axis_handler   axis_handler;
    pointer_motion_handler motion_handler;
    window_size_handler    size_handler;
    window_close_handler   close_handler;
    float                  width;
    float                  height;
} window_state_wl;

////// -------------------------- forward declarations;

static uint32_t evdev_to_keycode(uint32_t evdev_code);

static void shell_config(void* data, struct xdg_surface* shell_surface,
                         uint32_t serial);

static void shell_ping(void* data, struct xdg_wm_base* xdg_wm_base,
                       uint32_t serial);

static void setup_registry(void* data, struct wl_registry* registry,
                           uint32_t name, const char* interface,
                           uint32_t version);

static void toplevel_config(void* data, struct xdg_toplevel* toplevel,
                            int32_t width, int32_t height,
                            struct wl_array* states);

static void toplevel_close(void* data, struct xdg_toplevel* toplevel);

static void kb_key(void* data, struct wl_keyboard* keyboard, uint32_t serial,
                   uint32_t time, uint32_t key, uint32_t state);

static void kb_map(void* data, struct wl_keyboard* kb, uint32_t frmt,
                   int32_t fd, uint32_t sz);

static void kb_enter(void* data, struct wl_keyboard* kb, uint32_t ser,
                     struct wl_surface* srfc, struct wl_array* keys);

static void kb_leave(void* data, struct wl_keyboard* kb, uint32_t ser,
                     struct wl_surface* srfc);

static void kb_mod(void* data, struct wl_keyboard* kb, uint32_t ser,
                   uint32_t dep, uint32_t lat, uint32_t lock, uint32_t grp);

static void kb_rep(void* data, struct wl_keyboard* kb, int32_t rate,
                   int32_t del);

static void pointer_enter(void* data, struct wl_pointer* pointer,
                          uint32_t serial, struct wl_surface* surface,
                          wl_fixed_t sx, wl_fixed_t sy);

static void pointer_leave(void* data, struct wl_pointer* pointer,
                          uint32_t serial, struct wl_surface* surface);

static void pointer_motion(void* data, struct wl_pointer* pointer,
                           uint32_t time, wl_fixed_t sx, wl_fixed_t sy);

static void pointer_button(void* data, struct wl_pointer* pointer,
                           uint32_t serial, uint32_t time, uint32_t button,
                           uint32_t state);

static void pointer_axis(void* data, struct wl_pointer* pointer, uint32_t time,
                         uint32_t axis, wl_fixed_t value);

////// -------------------------- internal implementation;

static const struct wl_registry_listener registry_listener = {
    .global = setup_registry,
};

static const struct xdg_surface_listener shell_surface_listener = {
    .configure = shell_config,
};

static struct xdg_wm_base_listener shell_listener = {
    .ping = shell_ping,
};

static const struct xdg_toplevel_listener toplevel_listener = {
    .configure = toplevel_config,
    .close = toplevel_close,
};

static const struct wl_keyboard_listener kb_listener = {
    .keymap = kb_map,
    .enter = kb_enter,
    .leave = kb_leave,
    .key = kb_key,
    .modifiers = kb_mod,
    .repeat_info = kb_rep,
};

static const struct wl_pointer_listener pointer_listener = {
    .enter = pointer_enter,
    .leave = pointer_leave,
    .motion = pointer_motion,
    .button = pointer_button,
    .axis = pointer_axis,
};

////// -------------------------- interface implementation;

int32_t get_backend_state_size_wl() { return sizeof(window_state_wl); }

int32_t startup_wl(window_state* state) {
    window_state_wl* backend = (window_state_wl*)state;
    assert(backend);
    backend->handle.display = wl_display_connect(NULL);
    if (backend->handle.display == NULL) {
        printf("Failed to connect wl_display!\n");
        return -1;
    }

    backend->registry = wl_display_get_registry(backend->handle.display);
    if (backend->registry == NULL) {
        printf("Failed to get wayland registry!\n");
        return -1;
    }
    wl_registry_add_listener(backend->registry, &registry_listener, backend);
    wl_display_roundtrip(backend->handle.display);

    if (backend->compositor == NULL) {
        printf("Cannot open window - compositor is not initialized!");
        return -1;
    }
    return 0;
}

int32_t create_window_wl(window_state* state, window_params* params) {
    window_state_wl* backend = (window_state_wl*)state;
    assert(backend);
    backend->width = params->width;
    backend->height = params->height;
    backend->handle.surface = wl_compositor_create_surface(backend->compositor);
    if (backend->handle.surface == NULL) {
        printf("Failed to create wayland surface!\n");
        return -1;
    }

    backend->xdg_surface =
        xdg_wm_base_get_xdg_surface(backend->shell, backend->handle.surface);
    if (backend->xdg_surface == NULL) {
        printf("Failed to get xdg_surface!\n");
        return -1;
    }
    xdg_surface_add_listener(backend->xdg_surface, &shell_surface_listener,
                             backend);

    backend->toplevel = xdg_surface_get_toplevel(backend->xdg_surface);
    if (backend->toplevel == NULL) {
        printf("Failed to get xdg_toplevel!\n");
        return -1;
    }
    xdg_toplevel_add_listener(backend->toplevel, &toplevel_listener, backend);
    xdg_toplevel_set_title(backend->toplevel, params->title);
    xdg_toplevel_set_app_id(backend->toplevel, params->title);
    // xdg_toplevel_set_fullscreen(backend->toplevel, NULL);

    if (backend->seat) {
        backend->keyboard = wl_seat_get_keyboard(backend->seat);
        backend->pointer = wl_seat_get_pointer(backend->seat);
        wl_keyboard_add_listener(backend->keyboard, &kb_listener, backend);
        wl_pointer_add_listener(backend->pointer, &pointer_listener, backend);
    }
    wl_surface_commit(backend->handle.surface);
    wl_display_roundtrip(backend->handle.display);
    return 0;
}

void destroy_window_wl(window_state* state) {
    window_state_wl* backend = (window_state_wl*)state;
    assert(backend);
    xdg_toplevel_destroy(backend->toplevel);
    xdg_surface_destroy(backend->xdg_surface);
    wl_surface_destroy(backend->handle.surface);
}

void* get_window_handle_wl(window_state* state) {
    window_state_wl* backend = (window_state_wl*)state;
    assert(backend);
    return &backend->handle;
}

void poll_events_wl(window_state* state) {
    window_state_wl* backend = (window_state_wl*)state;
    assert(backend);
    wl_display_dispatch_pending(backend->handle.display);

    while (wl_display_prepare_read(backend->handle.display) != 0) {
        wl_display_dispatch_pending(backend->handle.display);
    }

    if (wl_display_read_events(backend->handle.display) != 0) {
        fprintf(stderr, "Failed to read Wayland events!\n");
    }

    wl_display_dispatch_pending(backend->handle.display);
    wl_display_flush(backend->handle.display);
}

void teardown_wl(window_state* state) {
    window_state_wl* backend = (window_state_wl*)state;
    assert(backend);
    xdg_wm_base_destroy(backend->shell);
    wl_compositor_destroy(backend->compositor);
    wl_registry_destroy(backend->registry);
    wl_display_disconnect(backend->handle.display);
}
void get_window_size_wl(window_state* state, uint32_t* width,
                        uint32_t* height) {
    window_state_wl* backend = (window_state_wl*)state;
    assert(backend);
    *width = backend->width;
    *height = backend->height;
}

void set_key_handler_wl(window_state* state, pfn_keyboard_key handler,
                        void* user) {
    window_state_wl* backend = (window_state_wl*)state;
    assert(backend);
    backend->key_handler = (keyboard_key_handler){
        .on_key = handler,
        .user_data = user,
    };
}

void set_pointer_button_handler_wl(window_state* state,
                                   pfn_pointer_button handler, void* user) {
    window_state_wl* backend = (window_state_wl*)state;
    assert(backend);
    backend->button_handler = (pointer_button_handler){
        .on_button = handler,
        .user_data = user,
    };
}

void set_pointer_motion_handler_wl(window_state* state,
                                   pfn_pointer_motion handler, void* user) {
    window_state_wl* backend = (window_state_wl*)state;
    assert(backend);
    backend->motion_handler = (pointer_motion_handler){
        .on_motion = handler,
        .user_data = user,
    };
}

void set_pointer_axis_handler_wl(window_state* state,
                                 pfn_pointer_axis handler, void* user) {
    window_state_wl* backend = (window_state_wl*)state;
    assert(backend);
    backend->axis_handler = (pointer_axis_handler){
        .on_axis = handler,
        .user_data = user,
    };
}

void set_window_size_handler_wl(window_state* state,
                                pfn_window_size handler, void* user) {
    window_state_wl* backend = (window_state_wl*)state;
    assert(backend);
    backend->size_handler = (window_size_handler){
        .on_size = handler,
        .user_data = user,
    };
}

void set_window_close_handler_wl(window_state* state,
                                 pfn_window_close handler, void* user) {
    window_state_wl* backend = (window_state_wl*)state;
    assert(backend);
    backend->close_handler = (window_close_handler){
        .on_close = handler,
        .user_data = user,
    };
}

void load_window_module_backend_wl(window_backend* backend) {
    backend->get_backend_state_size = get_backend_state_size_wl;
    backend->startup = startup_wl;
    backend->teardown = teardown_wl;
    backend->create_window = create_window_wl;
    backend->destroy_window = destroy_window_wl;
    backend->poll_events = poll_events_wl;
    backend->get_window_size = get_window_size_wl;
    backend->get_window_handle = get_window_handle_wl;
    backend->set_key_handler = set_key_handler_wl;
    backend->set_pointer_button_handler = set_pointer_button_handler_wl;
    backend->set_pointer_motion_handler = set_pointer_motion_handler_wl;
    backend->set_pointer_axis_handler = set_pointer_axis_handler_wl;
    backend->set_window_size_handler = set_window_size_handler_wl;
    backend->set_window_close_handler = set_window_close_handler_wl;
}

////// -------------------------- internal implementation;
static void setup_registry(void* data, struct wl_registry* registry,
                           uint32_t name, const char* interface,
                           uint32_t version) {
    window_state_wl* state = data;
    if (strcmp(interface, wl_compositor_interface.name) == 0) {
        state->compositor = wl_registry_bind(state->registry, name,
                                             &wl_compositor_interface, 1);
        return;
    }
    if (strcmp(interface, xdg_wm_base_interface.name) == 0) {
        state->shell =
            wl_registry_bind(registry, name, &xdg_wm_base_interface, 1);
        xdg_wm_base_add_listener(state->shell, &shell_listener, NULL);
        return;
    }
    if (strcmp(interface, wl_seat_interface.name) == 0) {
        state->seat = wl_registry_bind(registry, name, &wl_seat_interface, 1);
        return;
    }
}

static void shell_ping(void* data, struct xdg_wm_base* xdg_wm_base,
                       uint32_t serial) {
    xdg_wm_base_pong(xdg_wm_base, serial);
}

static void shell_config(void* data, struct xdg_surface* shell_surface,
                         uint32_t serial) {
    xdg_surface_ack_configure(shell_surface, serial);
    window_state_wl* backend = data;
    if (backend) wl_surface_commit(backend->handle.surface);
}

static void toplevel_config(void* data, struct xdg_toplevel* toplevel,
                            int32_t width, int32_t height,
                            struct wl_array* states) {
    window_state_wl* backend = data;
    assert(backend);
    float win_width = (float)width;
    float win_height = (float)height;
    if (backend->width == win_width && backend->height == win_height) return;

    backend->width = win_width;
    backend->height = win_height;
    if (backend->size_handler.on_size) {
        pfn_window_size on_size = backend->size_handler.on_size;
        void*           data = backend->size_handler.user_data;
        on_size(backend->width, backend->height, data);
    }
}

static void toplevel_close(void* data, struct xdg_toplevel* toplevel) {
    window_state_wl* backend = data;
    assert(backend);
    if (backend->close_handler.on_close) {
        backend->close_handler.on_close(backend->close_handler.user_data);
    }
}

static void kb_key(void* data, struct wl_keyboard* keyboard, uint32_t serial,
                   uint32_t time, uint32_t key, uint32_t state) {
    window_state_wl* backend = data;
    if (backend->key_handler.on_key) {
        pfn_keyboard_key on_key = backend->key_handler.on_key;
        void*            data = backend->key_handler.user_data;
        int32_t          key = evdev_to_keycode(key);
        on_key(key, state, data);
    }
}

static void kb_map(void* data, struct wl_keyboard* kb, uint32_t frmt,
                   int32_t fd, uint32_t sz) {
    // todo
}

static void kb_enter(void* data, struct wl_keyboard* kb, uint32_t ser,
                     struct wl_surface* srfc, struct wl_array* keys) {
    // todo
}

static void kb_leave(void* data, struct wl_keyboard* kb, uint32_t ser,
                     struct wl_surface* srfc) {
    // todo
}

static void kb_mod(void* data, struct wl_keyboard* kb, uint32_t ser,
                   uint32_t dep, uint32_t lat, uint32_t lock, uint32_t grp) {
    // todo
}

static void kb_rep(void* data, struct wl_keyboard* kb, int32_t rate,
                   int32_t del) {
    // todo
}

static void pointer_enter(void* data, struct wl_pointer* pointer,
                          uint32_t serial, struct wl_surface* surface,
                          wl_fixed_t sx, wl_fixed_t sy) {
    // todo
}

static void pointer_leave(void* data, struct wl_pointer* pointer,
                          uint32_t serial, struct wl_surface* surface) {
    // todo
}

static void pointer_motion(void* data, struct wl_pointer* pointer,
                           uint32_t time, wl_fixed_t sx, wl_fixed_t sy) {
    window_state_wl* backend = data;
    assert(backend);
    if (backend->motion_handler.on_motion) {
        float              x = wl_fixed_to_double(sx);
        float              y = wl_fixed_to_double(sy);
        pfn_pointer_motion on_motion = backend->motion_handler.on_motion;
        void*              data = backend->motion_handler.user_data;
        int32_t            key = evdev_to_keycode(key);
        on_motion(x, y, data);
    }
}

static void pointer_button(void* data, struct wl_pointer* pointer,
                           uint32_t serial, uint32_t time, uint32_t button,
                           uint32_t state) {
    window_state_wl* backend = data;
    assert(backend);
    if (backend->button_handler.on_button) {
        pfn_pointer_button on_button = backend->button_handler.on_button;
        void*              data = backend->button_handler.user_data;
        int32_t            button = evdev_to_keycode(button);
        on_button(button, state, data);
    }
}

static void pointer_axis(void* data, struct wl_pointer* pointer, uint32_t time,
                         uint32_t axis, wl_fixed_t value) {
    window_state_wl* backend = data;
    assert(backend);
    if (backend->button_handler.on_button) {
        float            scroll = wl_fixed_to_double(value);
        pfn_pointer_axis on_axis = backend->axis_handler.on_axis;
        void*            data = backend->button_handler.user_data;
        on_axis(scroll, data);
    }
}

#define P_KEY_RESERVED 0
#define P_KEY_ESC 1
#define P_KEY_1 2
#define P_KEY_2 3
#define P_KEY_3 4
#define P_KEY_4 5
#define P_KEY_5 6
#define P_KEY_6 7
#define P_KEY_7 8
#define P_KEY_8 9
#define P_KEY_9 10
#define P_KEY_0 11
#define P_KEY_MINUS 12
#define P_KEY_EQUAL 13
#define P_KEY_BACKSPACE 14
#define P_KEY_TAB 15
#define P_KEY_Q 16
#define P_KEY_W 17
#define P_KEY_E 18
#define P_KEY_R 19
#define P_KEY_T 20
#define P_KEY_Y 21
#define P_KEY_U 22
#define P_KEY_I 23
#define P_KEY_O 24
#define P_KEY_P 25
#define P_KEY_LEFTBRACE 26
#define P_KEY_RIGHTBRACE 27
#define P_KEY_ENTER 28
#define P_KEY_LEFTCTRL 29
#define P_KEY_A 30
#define P_KEY_S 31
#define P_KEY_D 32
#define P_KEY_F 33
#define P_KEY_G 34
#define P_KEY_H 35
#define P_KEY_J 36
#define P_KEY_K 37
#define P_KEY_L 38
#define P_KEY_SEMICOLON 39
#define P_KEY_APOSTROPHE 40
#define P_KEY_GRAVE 41
#define P_KEY_LEFTSHIFT 42
#define P_KEY_BACKSLASH 43
#define P_KEY_Z 44
#define P_KEY_X 45
#define P_KEY_C 46
#define P_KEY_V 47
#define P_KEY_B 48
#define P_KEY_N 49
#define P_KEY_M 50
#define P_KEY_COMMA 51
#define P_KEY_DOT 52
#define P_KEY_SLASH 53
#define P_KEY_RIGHTSHIFT 54
#define P_KEY_LEFTALT 56
#define P_KEY_SPACE 57
#define P_KEY_CAPSLOCK 58
#define P_KEY_F1 59
#define P_KEY_F2 60
#define P_KEY_F3 61
#define P_KEY_F4 62
#define P_KEY_F5 63
#define P_KEY_F6 64
#define P_KEY_F7 65
#define P_KEY_F8 66
#define P_KEY_F9 67
#define P_KEY_F10 68
#define P_KEY_F11 87
#define P_KEY_F12 88
#define P_KEY_RIGHT 106
#define P_KEY_LEFT 105
#define P_KEY_DOWN 108
#define P_KEY_UP 103
#define P_KEY_RIGHTCTRL 97
#define P_KEY_RIGHTALT 100
#define P_KEY_LEFTMETA 125
#define P_KEY_RIGHTMETA 126
#define P_BUTTON_LEFT 272
#define P_BUTTON_RIGHT 273
#define P_BUTTON_MIDDLE 274

static uint32_t evdev_to_keycode(uint32_t evdev_code) {
    switch (evdev_code) {
        case P_KEY_A:
            return KEY_A;
        case P_KEY_B:
            return KEY_B;
        case P_KEY_C:
            return KEY_C;
        case P_KEY_D:
            return KEY_D;
        case P_KEY_E:
            return KEY_E;
        case P_KEY_F:
            return KEY_F;
        case P_KEY_G:
            return KEY_G;
        case P_KEY_H:
            return KEY_H;
        case P_KEY_I:
            return KEY_I;
        case P_KEY_J:
            return KEY_J;
        case P_KEY_K:
            return KEY_K;
        case P_KEY_L:
            return KEY_L;
        case P_KEY_M:
            return KEY_M;
        case P_KEY_N:
            return KEY_N;
        case P_KEY_O:
            return KEY_O;
        case P_KEY_P:
            return KEY_P;
        case P_KEY_Q:
            return KEY_Q;
        case P_KEY_R:
            return KEY_R;
        case P_KEY_S:
            return KEY_S;
        case P_KEY_T:
            return KEY_T;
        case P_KEY_U:
            return KEY_U;
        case P_KEY_V:
            return KEY_V;
        case P_KEY_W:
            return KEY_W;
        case P_KEY_X:
            return KEY_X;
        case P_KEY_Y:
            return KEY_Y;
        case P_KEY_Z:
            return KEY_Z;
        case P_KEY_1:
            return KEY_1;
        case P_KEY_2:
            return KEY_2;
        case P_KEY_3:
            return KEY_3;
        case P_KEY_4:
            return KEY_4;
        case P_KEY_5:
            return KEY_5;
        case P_KEY_6:
            return KEY_6;
        case P_KEY_7:
            return KEY_7;
        case P_KEY_8:
            return KEY_8;
        case P_KEY_9:
            return KEY_9;
        case P_KEY_0:
            return KEY_0;
        case P_KEY_ENTER:
            return KEY_ENTER;
        case P_KEY_ESC:
            return KEY_ESCAPE;
        case P_KEY_BACKSPACE:
            return KEY_BACKSPACE;
        case P_KEY_TAB:
            return KEY_TAB;
        case P_KEY_SPACE:
            return KEY_SPACE;
        case P_KEY_MINUS:
            return KEY_MINUS;
        case P_KEY_EQUAL:
            return KEY_EQUAL;
        case P_KEY_LEFTBRACE:
            return KEY_LBRACE;
        case P_KEY_RIGHTBRACE:
            return KEY_RBRACE;
        case P_KEY_BACKSLASH:
            return KEY_BACKSLASH;
        case P_KEY_SEMICOLON:
            return KEY_SEMICOLON;
        case P_KEY_APOSTROPHE:
            return KEY_APOSTROPHE;
        case P_KEY_GRAVE:
            return KEY_GRAVEACCENT;
        case P_KEY_COMMA:
            return KEY_COMMA;
        case P_KEY_DOT:
            return KEY_PERIOD;
        case P_KEY_SLASH:
            return KEY_SLASH;
        case P_KEY_CAPSLOCK:
            return KEY_CAPSLOCK;
        case P_KEY_F1:
            return KEY_F1;
        case P_KEY_F2:
            return KEY_F2;
        case P_KEY_F3:
            return KEY_F3;
        case P_KEY_F4:
            return KEY_F4;
        case P_KEY_F5:
            return KEY_F5;
        case P_KEY_F6:
            return KEY_F6;
        case P_KEY_F7:
            return KEY_F7;
        case P_KEY_F8:
            return KEY_F8;
        case P_KEY_F9:
            return KEY_F9;
        case P_KEY_F10:
            return KEY_F10;
        case P_KEY_F11:
            return KEY_F11;
        case P_KEY_F12:
            return KEY_F12;
        case P_KEY_RIGHT:
            return KEY_RIGHT;
        case P_KEY_LEFT:
            return KEY_LEFT;
        case P_KEY_DOWN:
            return KEY_DOWN;
        case P_KEY_UP:
            return KEY_UP;
        case P_KEY_LEFTCTRL:
            return KEY_LCONTROL;
        case P_KEY_LEFTSHIFT:
            return KEY_LSHIFT;
        case P_KEY_LEFTALT:
            return KEY_LALT;
        case P_KEY_LEFTMETA:
            return KEY_LMETA;
        case P_KEY_RIGHTCTRL:
            return KEY_RCONTROL;
        case P_KEY_RIGHTSHIFT:
            return KEY_RSHIFT;
        case P_KEY_RIGHTALT:
            return KEY_RALT;
        case P_KEY_RIGHTMETA:
            return KEY_RMETA;
        case P_BUTTON_LEFT:
            return MOUSE_BUTTON_LEFT;
        case P_BUTTON_MIDDLE:
            return MOUSE_BUTTON_MIDDLE;
        case P_BUTTON_RIGHT:
            return MOUSE_BUTTON_RIGHT;
        default:
            return KEY_NONE;
    }
}
#endif  // WINDOW_BACKEND_LINUX
