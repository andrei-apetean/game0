#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
#include <wayland-client-core.h>
#include <wayland-client-protocol.h>
#include <wayland-client.h>  //libwayland-protocols
#include <xdg-shell.h>       //generated by wayland-scanner

#include "engine.h"
#include "private/base.h"
#include "private/input.h"
#include "private/window_backend.h"

// evdev key code values copied from <linux/input-event-codes.h>
#define P_KEY_RESERVED 0
#define P_KEY_ESC 1
#define P_KEY_1 2
#define P_KEY_2 3
#define P_KEY_3 4
#define P_KEY_4 5
#define P_KEY_5 6
#define P_KEY_6 7
#define P_KEY_7 8
#define P_KEY_8 9
#define P_KEY_9 10
#define P_KEY_0 11
#define P_KEY_MINUS 12
#define P_KEY_EQUAL 13
#define P_KEY_BACKSPACE 14
#define P_KEY_TAB 15
#define P_KEY_Q 16
#define P_KEY_W 17
#define P_KEY_E 18
#define P_KEY_R 19
#define P_KEY_T 20
#define P_KEY_Y 21
#define P_KEY_U 22
#define P_KEY_I 23
#define P_KEY_O 24
#define P_KEY_P 25
#define P_KEY_LEFTBRACE 26
#define P_KEY_RIGHTBRACE 27
#define P_KEY_ENTER 28
#define P_KEY_LEFTCTRL 29
#define P_KEY_A 30
#define P_KEY_S 31
#define P_KEY_D 32
#define P_KEY_F 33
#define P_KEY_G 34
#define P_KEY_H 35
#define P_KEY_J 36
#define P_KEY_K 37
#define P_KEY_L 38
#define P_KEY_SEMICOLON 39
#define P_KEY_APOSTROPHE 40
#define P_KEY_GRAVE 41
#define P_KEY_LEFTSHIFT 42
#define P_KEY_BACKSLASH 43
#define P_KEY_Z 44
#define P_KEY_X 45
#define P_KEY_C 46
#define P_KEY_V 47
#define P_KEY_B 48
#define P_KEY_N 49
#define P_KEY_M 50
#define P_KEY_COMMA 51
#define P_KEY_DOT 52
#define P_KEY_SLASH 53
#define P_KEY_RIGHTSHIFT 54
#define P_KEY_LEFTALT 56
#define P_KEY_SPACE 57
#define P_KEY_CAPSLOCK 58
#define P_KEY_F1 59
#define P_KEY_F2 60
#define P_KEY_F3 61
#define P_KEY_F4 62
#define P_KEY_F5 63
#define P_KEY_F6 64
#define P_KEY_F7 65
#define P_KEY_F8 66
#define P_KEY_F9 67
#define P_KEY_F10 68
#define P_KEY_F11 87
#define P_KEY_F12 88
#define P_KEY_RIGHT 106
#define P_KEY_LEFT 105
#define P_KEY_DOWN 108
#define P_KEY_UP 103
#define P_KEY_RIGHTCTRL 97
#define P_KEY_RIGHTALT 100
#define P_KEY_LEFTMETA 125
#define P_KEY_RIGHTMETA 126
#define P_BUTTON_LEFT 272
#define P_BUTTON_RIGHT 273
#define P_BUTTON_MIDDLE 274

typedef struct {
    struct wl_display*    display;
    struct wl_registry*   registry;
    struct wl_compositor* compositor;
    struct xdg_wm_base*   shell;

    struct wl_seat*     seat;
    struct wl_keyboard* keyboard;
    struct wl_pointer*  pointer;

    struct wl_shm*      shm;
    struct wl_shm_pool* pool;
    struct wl_buffer*   buffer;

    struct wl_surface*   surface;
    struct xdg_surface*  xdg_surface;
    struct xdg_toplevel* toplevel;
    pfn_on_input_event   on_event;
    float                width;
    float                height;
} backend_wl;

////// -------------------------- forward declarations;
//
static uint32_t evdev_to_keycode(uint32_t evdev_code);

static void sh_config(void* data, struct xdg_surface* shell_surface,
                      uint32_t serial);

static void sh_ping(void* data, struct xdg_wm_base* xdg_wm_base,
                    uint32_t serial);

static void setup_reg(void* data, struct wl_registry* registry, uint32_t name,
                      const char* interface, uint32_t version);

static void toplvl_config(void* data, struct xdg_toplevel* toplevel,
                          int32_t width, int32_t height,
                          struct wl_array* states);

static void toplvl_close(void* data, struct xdg_toplevel* toplevel);

static void kb_key(void* data, struct wl_keyboard* keyboard, uint32_t serial,
                   uint32_t time, uint32_t key, uint32_t state);

static void kb_map(void* data, struct wl_keyboard* kb, uint32_t frmt,
                   int32_t fd, uint32_t sz);

static void kb_enter(void* data, struct wl_keyboard* kb, uint32_t ser,
                     struct wl_surface* srfc, struct wl_array* keys);

static void kb_leave(void* data, struct wl_keyboard* kb, uint32_t ser,
                     struct wl_surface* srfc);

static void kb_mod(void* data, struct wl_keyboard* kb, uint32_t ser,
                   uint32_t dep, uint32_t lat, uint32_t lock, uint32_t grp);

static void kb_rep(void* data, struct wl_keyboard* kb, int32_t rate,
                   int32_t del);

static void pointer_enter(void* data, struct wl_pointer* pointer,
                          uint32_t serial, struct wl_surface* surface,
                          wl_fixed_t sx, wl_fixed_t sy);

static void pointer_leave(void* data, struct wl_pointer* pointer,
                          uint32_t serial, struct wl_surface* surface);

static void pointer_motion(void* data, struct wl_pointer* pointer,
                           uint32_t time, wl_fixed_t sx, wl_fixed_t sy);

static void pointer_button(void* data, struct wl_pointer* pointer,
                           uint32_t serial, uint32_t time, uint32_t button,
                           uint32_t state);

static void pointer_axis(void* data, struct wl_pointer* pointer, uint32_t time,
                         uint32_t axis, wl_fixed_t value);

////// -------------------------- internal implementation;
//

static const struct wl_registry_listener reg_listnr = {
    .global = setup_reg,
};

static const struct xdg_surface_listener sh_surf_listnr = {
    .configure = sh_config,
};

static struct xdg_wm_base_listener sh_listnr = {
    .ping = sh_ping,
};

static const struct xdg_toplevel_listener toplvl_listnr = {
    .configure = toplvl_config,
    .close = toplvl_close,
};

static const struct wl_keyboard_listener kb_listnr = {
    .keymap = kb_map,
    .enter = kb_enter,
    .leave = kb_leave,
    .key = kb_key,
    .modifiers = kb_mod,
    .repeat_info = kb_rep,
};

static const struct wl_pointer_listener pointer_listnr = {
    .enter = pointer_enter,
    .leave = pointer_leave,
    .motion = pointer_motion,
    .button = pointer_button,
    .axis = pointer_axis,
};

static void setup_reg(void* data, struct wl_registry* registry, uint32_t name,
                      const char* interface, uint32_t version) {
    backend_wl* state = data;
    if (strcmp(interface, wl_compositor_interface.name) == 0) {
        state->compositor = wl_registry_bind(state->registry, name,
                                             &wl_compositor_interface, 1);
        return;
    }
    if (strcmp(interface, xdg_wm_base_interface.name) == 0) {
        state->shell =
            wl_registry_bind(registry, name, &xdg_wm_base_interface, 1);
        xdg_wm_base_add_listener(state->shell, &sh_listnr, NULL);
        return;
    }
    if (strcmp(interface, wl_seat_interface.name) == 0) {
        state->seat = wl_registry_bind(registry, name, &wl_seat_interface, 1);
        return;
    }
}

static void sh_ping(void* data, struct xdg_wm_base* xdg_wm_base,
                    uint32_t serial) {
    xdg_wm_base_pong(xdg_wm_base, serial);
}

static void sh_config(void* data, struct xdg_surface* shell_surface,
                      uint32_t serial) {
    xdg_surface_ack_configure(shell_surface, serial);
    backend_wl* backend = data;
    if (backend) wl_surface_commit(backend->surface);
}

static void toplvl_config(void* data, struct xdg_toplevel* toplevel,
                          int32_t width, int32_t height,
                          struct wl_array* states) {
    backend_wl* backend = data;
    ASSERT(backend);
    float win_width = (float)width;
    float win_height = (float)height;
    if (backend->width == win_width && backend->height == win_height) return;

    backend->width = win_width;
    backend->height = win_height;
    if (!backend->on_event) return;
    input_ev e = {
        .type = INPUT_EVENT_SIZE,
        .window.width = width,
        .window.height = height,
    };
    backend->on_event(e);
}

static void toplvl_close(void* data, struct xdg_toplevel* toplevel) {
    backend_wl* backend = data;
    ASSERT(backend);
    if (!backend->on_event) return;
    input_ev e = {.type = INPUT_EVENT_QUIT};
    backend->on_event(e);
}

static void kb_key(void* data, struct wl_keyboard* keyboard, uint32_t serial,
                   uint32_t time, uint32_t key, uint32_t state) {
    backend_wl* backend = data;
    input_ev    ev = {
           .type = INPUT_EVENT_KEY,
           .key.code = evdev_to_keycode(key),
           .key.state = state,
    };
    if (!backend->on_event) return;
    backend->on_event(ev);
}

static void kb_map(void* data, struct wl_keyboard* kb, uint32_t frmt,
                   int32_t fd, uint32_t sz) {
    // todo
}

static void kb_enter(void* data, struct wl_keyboard* kb, uint32_t ser,
                     struct wl_surface* srfc, struct wl_array* keys) {
    // todo
}

static void kb_leave(void* data, struct wl_keyboard* kb, uint32_t ser,
                     struct wl_surface* srfc) {
    // todo
}

static void kb_mod(void* data, struct wl_keyboard* kb, uint32_t ser,
                   uint32_t dep, uint32_t lat, uint32_t lock, uint32_t grp) {
    // todo
}

static void kb_rep(void* data, struct wl_keyboard* kb, int32_t rate,
                   int32_t del) {
    // todo
}

static void pointer_enter(void* data, struct wl_pointer* pointer,
                          uint32_t serial, struct wl_surface* surface,
                          wl_fixed_t sx, wl_fixed_t sy) {
    // todo
}

static void pointer_leave(void* data, struct wl_pointer* pointer,
                          uint32_t serial, struct wl_surface* surface) {
    // todo
}

static void pointer_motion(void* data, struct wl_pointer* pointer,
                           uint32_t time, wl_fixed_t sx, wl_fixed_t sy) {
    backend_wl* backend = data;
    ASSERT(backend);
    if (!backend->on_event) return;
    float    x = wl_fixed_to_double(sx);
    float    y = wl_fixed_to_double(sy);
    input_ev e = {
        .type = INPUT_EVENT_POINTER,
        .pointer.x = x,
        .pointer.y = y,
    };
    backend->on_event(e);
}

static void pointer_button(void* data, struct wl_pointer* pointer,
                           uint32_t serial, uint32_t time, uint32_t button,
                           uint32_t state) {
    backend_wl* backend = data;
    ASSERT(backend);
    if (!backend->on_event) return;
    input_ev e = {
        .type = INPUT_EVENT_KEY,
        .key.code = evdev_to_keycode(button),
        .key.state = state,
    };
    backend->on_event(e);
}

static void pointer_axis(void* data, struct wl_pointer* pointer, uint32_t time,
                         uint32_t axis, wl_fixed_t value) {
    backend_wl* backend = data;
    ASSERT(backend);
    if (!backend->on_event) return;
    input_ev e = {
        .type = INPUT_EVENT_SCROLL,
        .scroll.value = wl_fixed_to_double(value),
    };
    backend->on_event(e);
}

////// -------------------------- backend interface;
//
int32_t window_backend_get_size() { return sizeof(backend_wl); }

int32_t window_backend_startup(window_backend** backend, window_cfg cfg) {
    backend_wl* state = (backend_wl*)(*backend);
    ASSERT(state);
    memset(state, 0, sizeof(*state));

    state->display = wl_display_connect(NULL);
    if (state->display == NULL) {
        printf("Failed to connect wl_display!\n");
        return -1;
    }

    state->registry = wl_display_get_registry(state->display);
    if (state->registry == NULL) {
        printf("Failed to get wayland registry!\n");
        return -1;
    }
    wl_registry_add_listener(state->registry, &reg_listnr, state);
    wl_display_roundtrip(state->display);

    if (state->compositor == NULL) {
        printf("Cannot open window - compositor is not initialized!");
        return -1;
    }
    // window creation
    state->surface = wl_compositor_create_surface(state->compositor);
    if (state->surface == NULL) {
        printf("Failed to create wayland surface!\n");
        return -1;
    }

    state->xdg_surface =
        xdg_wm_base_get_xdg_surface(state->shell, state->surface);
    if (state->xdg_surface == NULL) {
        printf("Failed to get xdg_surface!\n");
        return -1;
    }
    xdg_surface_add_listener(state->xdg_surface, &sh_surf_listnr, state);

    state->toplevel = xdg_surface_get_toplevel(state->xdg_surface);
    if (state->toplevel == NULL) {
        printf("Failed to get xdg_toplevel!\n");
        return -1;
    }
    xdg_toplevel_add_listener(state->toplevel, &toplvl_listnr, state);
    xdg_toplevel_set_title(state->toplevel, cfg.title);

    if (state->seat) {
        state->keyboard = wl_seat_get_keyboard(state->seat);
        state->pointer = wl_seat_get_pointer(state->seat);
        wl_keyboard_add_listener(state->keyboard, &kb_listnr, state);
        wl_pointer_add_listener(state->pointer, &pointer_listnr, state);
    }
    wl_surface_commit(state->surface);
    wl_display_roundtrip(state->display);
    return 0;
}

void window_backend_teardown(window_backend* backend) {
    backend_wl* state = (backend_wl*)backend;
    ASSERT(state);
    xdg_toplevel_destroy(state->toplevel);
    xdg_surface_destroy(state->xdg_surface);
    wl_surface_destroy(state->surface);
    xdg_wm_base_destroy(state->shell);
    wl_compositor_destroy(state->compositor);
    wl_registry_destroy(state->registry);
    wl_display_disconnect(state->display);
}

void window_backend_poll_events(window_backend* backend) {
    backend_wl* state = (backend_wl*)backend;
    ASSERT(state);
    wl_display_dispatch_pending(state->display);

  while (wl_display_prepare_read(state->display) != 0) {
        wl_display_dispatch_pending(state->display);
    }

    if (wl_display_read_events(state->display) != 0) {
        fprintf(stderr, "Failed to read Wayland events!\n");
        return;
    }

    wl_display_dispatch_pending(state->display);
    wl_display_flush(state->display); 
}

void window_backend_attach_handler(window_backend*    backend,
                                   pfn_on_input_event handler) {
    backend_wl* state = (backend_wl*)backend;
    ASSERT(state);
    state->on_event = handler;
}

vec2 window_backend_window_size(window_backend* backend) {
    backend_wl* state = (backend_wl*)backend;
    ASSERT(state);
    return (vec2){state->width, state->height};
}

// todo hack
window_info window_backend_get_info(window_backend* backend) {
    backend_wl* state = (backend_wl*)backend;
    ASSERT(state);
    window_info info = {.win_api = 0,
                        .win_handle = state->surface,
                        .win_instance = state->display};
    return info;
}

static uint32_t evdev_to_keycode(uint32_t evdev_code) {
    switch (evdev_code) {
        case P_KEY_A:
            return KEY_A;
        case P_KEY_B:
            return KEY_B;
        case P_KEY_C:
            return KEY_C;
        case P_KEY_D:
            return KEY_D;
        case P_KEY_E:
            return KEY_E;
        case P_KEY_F:
            return KEY_F;
        case P_KEY_G:
            return KEY_G;
        case P_KEY_H:
            return KEY_H;
        case P_KEY_I:
            return KEY_I;
        case P_KEY_J:
            return KEY_J;
        case P_KEY_K:
            return KEY_K;
        case P_KEY_L:
            return KEY_L;
        case P_KEY_M:
            return KEY_M;
        case P_KEY_N:
            return KEY_N;
        case P_KEY_O:
            return KEY_O;
        case P_KEY_P:
            return KEY_P;
        case P_KEY_Q:
            return KEY_Q;
        case P_KEY_R:
            return KEY_R;
        case P_KEY_S:
            return KEY_S;
        case P_KEY_T:
            return KEY_T;
        case P_KEY_U:
            return KEY_U;
        case P_KEY_V:
            return KEY_V;
        case P_KEY_W:
            return KEY_W;
        case P_KEY_X:
            return KEY_X;
        case P_KEY_Y:
            return KEY_Y;
        case P_KEY_Z:
            return KEY_Z;
        case P_KEY_1:
            return KEY_1;
        case P_KEY_2:
            return KEY_2;
        case P_KEY_3:
            return KEY_3;
        case P_KEY_4:
            return KEY_4;
        case P_KEY_5:
            return KEY_5;
        case P_KEY_6:
            return KEY_6;
        case P_KEY_7:
            return KEY_7;
        case P_KEY_8:
            return KEY_8;
        case P_KEY_9:
            return KEY_9;
        case P_KEY_0:
            return KEY_0;
        case P_KEY_ENTER:
            return KEY_ENTER;
        case P_KEY_ESC:
            return KEY_ESCAPE;
        case P_KEY_BACKSPACE:
            return KEY_BACKSPACE;
        case P_KEY_TAB:
            return KEY_TAB;
        case P_KEY_SPACE:
            return KEY_SPACE;
        case P_KEY_MINUS:
            return KEY_MINUS;
        case P_KEY_EQUAL:
            return KEY_EQUAL;
        case P_KEY_LEFTBRACE:
            return KEY_LBRACE;
        case P_KEY_RIGHTBRACE:
            return KEY_RBRACE;
        case P_KEY_BACKSLASH:
            return KEY_BACKSLASH;
        case P_KEY_SEMICOLON:
            return KEY_SEMICOLON;
        case P_KEY_APOSTROPHE:
            return KEY_APOSTROPHE;
        case P_KEY_GRAVE:
            return KEY_GRAVEACCENT;
        case P_KEY_COMMA:
            return KEY_COMMA;
        case P_KEY_DOT:
            return KEY_PERIOD;
        case P_KEY_SLASH:
            return KEY_SLASH;
        case P_KEY_CAPSLOCK:
            return KEY_CAPSLOCK;
        case P_KEY_F1:
            return KEY_F1;
        case P_KEY_F2:
            return KEY_F2;
        case P_KEY_F3:
            return KEY_F3;
        case P_KEY_F4:
            return KEY_F4;
        case P_KEY_F5:
            return KEY_F5;
        case P_KEY_F6:
            return KEY_F6;
        case P_KEY_F7:
            return KEY_F7;
        case P_KEY_F8:
            return KEY_F8;
        case P_KEY_F9:
            return KEY_F9;
        case P_KEY_F10:
            return KEY_F10;
        case P_KEY_F11:
            return KEY_F11;
        case P_KEY_F12:
            return KEY_F12;
        case P_KEY_RIGHT:
            return KEY_RIGHT;
        case P_KEY_LEFT:
            return KEY_LEFT;
        case P_KEY_DOWN:
            return KEY_DOWN;
        case P_KEY_UP:
            return KEY_UP;
        case P_KEY_LEFTCTRL:
            return KEY_LCONTROL;
        case P_KEY_LEFTSHIFT:
            return KEY_LSHIFT;
        case P_KEY_LEFTALT:
            return KEY_LALT;
        case P_KEY_LEFTMETA:
            return KEY_LMETA;
        case P_KEY_RIGHTCTRL:
            return KEY_RCONTROL;
        case P_KEY_RIGHTSHIFT:
            return KEY_RSHIFT;
        case P_KEY_RIGHTALT:
            return KEY_RALT;
        case P_KEY_RIGHTMETA:
            return KEY_RMETA;
        case P_BUTTON_LEFT:
            return MOUSE_BUTTON_LEFT;
        case P_BUTTON_MIDDLE:
            return MOUSE_BUTTON_MIDDLE;
        case P_BUTTON_RIGHT:
            return MOUSE_BUTTON_RIGHT;
        default:
            return KEY_NONE;
    }
}
