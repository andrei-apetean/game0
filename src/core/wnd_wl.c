#include "base.h"
#include "os_event.h"
#include "wnd.h"
#include "wnd_backend.h"

#ifdef WINDOW_BACKEND_LINUX
#include <fcntl.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
#include <wayland-client-core.h>
#include <wayland-client-protocol.h>
#include <wayland-client.h>     //libwayland-protocols
#include <wayland/xdg-shell.h>  //generated by wayland-scanner

// todo; don't link with wl, load it dynamically when adding xcb backend

typedef struct {
    struct wl_display* display;
    struct wl_surface* surface;
} handle_wl;

typedef struct {
    handle_wl             handle;
    struct wl_registry*   registry;
    struct wl_compositor* compositor;
    struct xdg_wm_base*   shell;
    struct wl_seat*       seat;
    struct wl_keyboard*   keyboard;
    struct wl_pointer*    pointer;
    struct xdg_surface*   xdg_surface;
    struct xdg_toplevel*  toplevel;

    struct wl_shm*      shm;
    struct wl_shm_pool* pool;
    struct wl_buffer*   buffer;

    wnd_dispatcher dispatcher;
    float          width;
    float          height;
    uint32_t       configured;
    uint32_t       pending_width;
    uint32_t       pending_height;
    uint32_t       needs_buffer_resize;
} wnd_wl;

// todo; i'm not really a huge fan of this static backend
static wnd_wl backend;

// =======================================================
//
// forward declarations;
//
// =======================================================

static int  create_shm_file(size_t size);
static void create_shm_buffer(uint32_t width, uint32_t height);

static uint32_t evdev_to_keycode(uint32_t evdev_code);

static void shell_config(void* data, struct xdg_surface* shell_surface,
                         uint32_t serial);

static void shell_ping(void* data, struct xdg_wm_base* xdg_wm_base,
                       uint32_t serial);

static void setup_registry(void* data, struct wl_registry* registry, uint32_t name,
                           const char* interface, uint32_t version);

static void toplevel_config(void* data, struct xdg_toplevel* toplevel,
                            int32_t width, int32_t height, struct wl_array* states);

static void toplevel_close(void* data, struct xdg_toplevel* toplevel);

static void kb_key(void* data, struct wl_keyboard* keyboard, uint32_t serial,
                   uint32_t time, uint32_t key, uint32_t state);

static void kb_map(void* data, struct wl_keyboard* kb, uint32_t frmt, int32_t fd,
                   uint32_t sz);

static void kb_enter(void* data, struct wl_keyboard* kb, uint32_t ser,
                     struct wl_surface* srfc, struct wl_array* keys);

static void kb_leave(void* data, struct wl_keyboard* kb, uint32_t ser,
                     struct wl_surface* srfc);

static void kb_mod(void* data, struct wl_keyboard* kb, uint32_t ser, uint32_t dep,
                   uint32_t lat, uint32_t lock, uint32_t grp);

static void kb_rep(void* data, struct wl_keyboard* kb, int32_t rate, int32_t del);

static void pointer_enter(void* data, struct wl_pointer* pointer, uint32_t serial,
                          struct wl_surface* surface, wl_fixed_t sx, wl_fixed_t sy);

static void pointer_leave(void* data, struct wl_pointer* pointer, uint32_t serial,
                          struct wl_surface* surface);

static void pointer_motion(void* data, struct wl_pointer* pointer, uint32_t time,
                           wl_fixed_t sx, wl_fixed_t sy);

static void pointer_button(void* data, struct wl_pointer* pointer, uint32_t serial,
                           uint32_t time, uint32_t button, uint32_t state);

static void pointer_axis(void* data, struct wl_pointer* pointer, uint32_t time,
                         uint32_t axis, wl_fixed_t value);
// =======================================================
//
// internal implementation;
//
// =======================================================

static const struct wl_registry_listener registry_listener = {
    .global = setup_registry,
};

static const struct xdg_surface_listener shell_surface_listener = {
    .configure = shell_config,
};

static struct xdg_wm_base_listener shell_listener = {
    .ping = shell_ping,
};

static const struct xdg_toplevel_listener toplevel_listener = {
    .configure = toplevel_config,
    .close = toplevel_close,
};

static const struct wl_keyboard_listener kb_listener = {
    .keymap = kb_map,
    .enter = kb_enter,
    .leave = kb_leave,
    .key = kb_key,
    .modifiers = kb_mod,
    .repeat_info = kb_rep,
};

static const struct wl_pointer_listener pointer_listener = {
    .enter = pointer_enter,
    .leave = pointer_leave,
    .motion = pointer_motion,
    .button = pointer_button,
    .axis = pointer_axis,
};

// =======================================================
//
// interface implementation;
//
// =======================================================

void wnd_init_wl() {
    backend.handle.display = wl_display_connect(NULL);
    debug_assert(backend.handle.display);

    backend.registry = wl_display_get_registry(backend.handle.display);
    debug_assert(backend.registry);

    wl_registry_add_listener(backend.registry, &registry_listener, &backend);
    wl_display_roundtrip(backend.handle.display);
    debug_assert(backend.compositor);
}

void wnd_open_wl(const char* title, uint32_t w, uint32_t h) {
    backend.width = w;
    backend.height = h;
    backend.configured = 0;
    backend.needs_buffer_resize = 0;
    backend.buffer = NULL;  // Initialize to NULL

    backend.handle.surface = wl_compositor_create_surface(backend.compositor);
    debug_assert(backend.handle.surface);

    backend.xdg_surface =
        xdg_wm_base_get_xdg_surface(backend.shell, backend.handle.surface);
    debug_assert(backend.xdg_surface);

    xdg_surface_add_listener(backend.xdg_surface, &shell_surface_listener,
                             &backend);

    backend.toplevel = xdg_surface_get_toplevel(backend.xdg_surface);
    debug_assert(backend.toplevel);

    xdg_toplevel_add_listener(backend.toplevel, &toplevel_listener, &backend);
    xdg_toplevel_set_title(backend.toplevel, title);
    xdg_toplevel_set_app_id(backend.toplevel, title);

    // Set up input devices
    if (backend.seat) {
        backend.keyboard = wl_seat_get_keyboard(backend.seat);
        backend.pointer = wl_seat_get_pointer(backend.seat);
        wl_keyboard_add_listener(backend.keyboard, &kb_listener, &backend);
        wl_pointer_add_listener(backend.pointer, &pointer_listener, &backend);
    }

    // Commit to trigger initial configure events
    wl_surface_commit(backend.handle.surface);

    // Wait for window to be configured (buffer will be created in shell_config)
    while (!backend.configured) {
        wl_display_dispatch(backend.handle.display);
    }
}

void* wnd_window_handle_wl() { return &backend.handle; }

void wnd_dispatch_events_wl() {
    wl_display_dispatch_pending(backend.handle.display);

    while (wl_display_prepare_read(backend.handle.display) != 0) {
        wl_display_dispatch_pending(backend.handle.display);
    }

    if (wl_display_read_events(backend.handle.display) != 0) {
        debug_log("Failed to read Wayland events!\n");
    }

    wl_display_dispatch_pending(backend.handle.display);
    wl_display_flush(backend.handle.display);
}

void wnd_terminate_wl() {
    xdg_toplevel_destroy(backend.toplevel);
    xdg_surface_destroy(backend.xdg_surface);
    wl_surface_destroy(backend.handle.surface);

    xdg_wm_base_destroy(backend.shell);
    wl_compositor_destroy(backend.compositor);
    wl_registry_destroy(backend.registry);
    wl_display_disconnect(backend.handle.display);
}

void wnd_set_title_wl(const char* title) {
    xdg_toplevel_set_title(backend.toplevel, title);
    xdg_toplevel_set_app_id(backend.toplevel, title);
}

void wnd_get_size_wl(uint32_t* w, uint32_t* h) {
    *w = backend.width;
    *h = backend.height;
}

void wnd_attach_dispatcher_wl(wnd_dispatcher* disp) {
    backend.dispatcher.on_key = disp->on_key;
    backend.dispatcher.on_pointer_axis = disp->on_pointer_axis;
    backend.dispatcher.on_pointer_button = disp->on_pointer_button;
    backend.dispatcher.on_pointer_motion = disp->on_pointer_motion;
    backend.dispatcher.on_window_size = disp->on_window_size;
    backend.dispatcher.on_window_close = disp->on_window_close;
    backend.dispatcher.user_data = disp->user_data;
}

uint32_t wnd_backend_id_wl() { return WINDOW_BACKEND_WL_ID; }

void load_wnd_wl(wnd_api* api) {
    api->init = wnd_init_wl;
    api->terminate = wnd_terminate_wl;
    api->open = wnd_open_wl;
    api->dispatch_events = wnd_dispatch_events_wl;
    api->backend_id = wnd_backend_id_wl;
    api->native_handle = wnd_window_handle_wl;
    api->set_title = wnd_set_title_wl;
    api->get_size = wnd_get_size_wl;
    api->attach_dispatcher = wnd_attach_dispatcher_wl;
    // api->get_window_size = get_window_size_wl;
}

////// -------------------------- internal implementation;
static void setup_registry(void* data, struct wl_registry* registry, uint32_t name,
                           const char* interface, uint32_t version) {
    unused(version);
    wnd_wl* state = data;
    debug_assert(data);
    if (strcmp(interface, wl_compositor_interface.name) == 0) {
        state->compositor =
            wl_registry_bind(state->registry, name, &wl_compositor_interface, 1);
        return;
    }
    if (strcmp(interface, xdg_wm_base_interface.name) == 0) {
        state->shell = wl_registry_bind(registry, name, &xdg_wm_base_interface, 1);
        xdg_wm_base_add_listener(state->shell, &shell_listener, NULL);
        return;
    }
    if (strcmp(interface, wl_seat_interface.name) == 0) {
        state->seat = wl_registry_bind(registry, name, &wl_seat_interface, 1);
        return;
    }

    if (strcmp(interface, wl_shm_interface.name) == 0) {
        state->shm = wl_registry_bind(registry, name, &wl_shm_interface, 1);
        return;
    }
}

static void shell_ping(void* data, struct xdg_wm_base* xdg_wm_base,
                       uint32_t serial) {
    unused(data);
    xdg_wm_base_pong(xdg_wm_base, serial);
}

static void shell_config(void* data, struct xdg_surface* shell_surface,
                         uint32_t serial) {
    xdg_surface_ack_configure(shell_surface, serial);
    wnd_wl* backend = data;

    if (!backend->configured) {
        backend->configured = 1;
    }

    wl_surface_commit(backend->handle.surface);
}

static void toplevel_config(void* data, struct xdg_toplevel* toplevel,
                            int32_t width, int32_t height,
                            struct wl_array* states) {
    unused(toplevel);
    unused(states);
    wnd_wl* backend = data;

    // Handle zero dimensions
    if (width == 0 || height == 0) {
        return;
    }

    float win_width = (float)width;
    float win_height = (float)height;

    if (backend->width == win_width && backend->height == win_height) {
        return;
    }

    backend->pending_width = width;
    backend->pending_height = height;
    backend->width = win_width;
    backend->height = win_height;
    backend->needs_buffer_resize = 1;

    if (backend->dispatcher.on_window_size) {
        backend->dispatcher.on_window_size(win_width, win_height,
                                           backend->dispatcher.user_data);
    }
}

static void toplevel_close(void* data, struct xdg_toplevel* toplevel) {
    unused(toplevel);
    wnd_wl* backend = data;
    debug_assert(backend);
    if (backend->dispatcher.on_window_close) {
        backend->dispatcher.on_window_close(backend->dispatcher.user_data);
    }
}

static void kb_key(void* data, struct wl_keyboard* keyboard, uint32_t serial,
                   uint32_t time, uint32_t key, uint32_t state) {
    unused(keyboard);
    unused(serial);
    unused(time);
    wnd_wl* backend = data;
    if (backend->dispatcher.on_key) {
        void*   data = backend->dispatcher.user_data;
        int32_t key_code = evdev_to_keycode(key);
        backend->dispatcher.on_key(key_code, state, data);
    }
}

static void kb_map(void* data, struct wl_keyboard* kb, uint32_t frmt, int32_t fd,
                   uint32_t sz) {
    unused(data);
    unused(kb);
    unused(frmt);
    unused(fd);
    unused(sz);
    // todo
}

static void kb_enter(void* data, struct wl_keyboard* kb, uint32_t ser,
                     struct wl_surface* srfc, struct wl_array* keys) {
    unused(data);
    unused(kb);
    unused(ser);
    unused(srfc);
    unused(keys);
    // todo
}

static void kb_leave(void* data, struct wl_keyboard* kb, uint32_t ser,
                     struct wl_surface* srfc) {
    unused(data);
    unused(kb);
    unused(ser);
    unused(srfc);
    // todo
}

static void kb_mod(void* data, struct wl_keyboard* kb, uint32_t ser, uint32_t dep,
                   uint32_t lat, uint32_t lock, uint32_t grp) {
    unused(data);
    unused(kb);
    unused(ser);
    unused(dep);
    unused(lat);
    unused(lock);
    unused(grp);
    // todo
}

static void kb_rep(void* data, struct wl_keyboard* kb, int32_t rate, int32_t del) {
    unused(data);
    unused(kb);
    unused(rate);
    unused(del);
    // todo
}

static void pointer_enter(void* data, struct wl_pointer* pointer, uint32_t serial,
                          struct wl_surface* surface, wl_fixed_t sx,
                          wl_fixed_t sy) {
    unused(data);
    unused(pointer);
    unused(serial);
    unused(surface);
    unused(sx);
    unused(sy);
    // todo
}

static void pointer_leave(void* data, struct wl_pointer* pointer, uint32_t serial,
                          struct wl_surface* surface) {
    unused(data);
    unused(pointer);
    unused(serial);
    unused(surface);
    // todo
}

static void pointer_motion(void* data, struct wl_pointer* pointer, uint32_t time,
                           wl_fixed_t sx, wl_fixed_t sy) {
    unused(pointer);
    unused(time);
    wnd_wl* backend = data;
    debug_assert(backend);
    if (!backend->dispatcher.on_pointer_motion) {
        return;
    }
    float x = wl_fixed_to_double(sx);
    float y = wl_fixed_to_double(sy);
    void* udata = backend->dispatcher.user_data;
    backend->dispatcher.on_pointer_motion(x, y, udata);
}

static void pointer_button(void* data, struct wl_pointer* pointer, uint32_t serial,
                           uint32_t time, uint32_t button, uint32_t state) {
    unused(pointer);
    unused(serial);
    unused(time);
    wnd_wl* backend = data;
    debug_assert(backend);
    if (!backend->dispatcher.on_pointer_button) {
        return;
    }
    void*   udata = backend->dispatcher.user_data;
    int32_t button_code = evdev_to_keycode(button);
    backend->dispatcher.on_pointer_button(button_code, state, udata);
}

static void pointer_axis(void* data, struct wl_pointer* pointer, uint32_t time,
                         uint32_t axis, wl_fixed_t value) {
    unused(pointer);
    unused(time);
    unused(axis);
    wnd_wl* backend = data;
    debug_assert(backend);
    if (!backend->dispatcher.on_pointer_axis) {
        return;
    }
    float scroll = wl_fixed_to_double(value);
    void* udata = backend->dispatcher.user_data;
    backend->dispatcher.on_pointer_axis(scroll, udata);
}

static uint32_t evdev_to_keycode(uint32_t evdev_code) {
    switch (evdev_code) {
        case 30:
            return KEY_A;
        case 48:
            return KEY_B;
        case 46:
            return KEY_C;
        case 32:
            return KEY_D;
        case 18:
            return KEY_E;
        case 33:
            return KEY_F;
        case 34:
            return KEY_G;
        case 35:
            return KEY_H;
        case 23:
            return KEY_I;
        case 36:
            return KEY_J;
        case 37:
            return KEY_K;
        case 38:
            return KEY_L;
        case 50:
            return KEY_M;
        case 49:
            return KEY_N;
        case 24:
            return KEY_O;
        case 25:
            return KEY_P;
        case 16:
            return KEY_Q;
        case 19:
            return KEY_R;
        case 31:
            return KEY_S;
        case 20:
            return KEY_T;
        case 22:
            return KEY_U;
        case 47:
            return KEY_V;
        case 17:
            return KEY_W;
        case 45:
            return KEY_X;
        case 21:
            return KEY_Y;
        case 44:
            return KEY_Z;
        case 2:
            return KEY_1;
        case 3:
            return KEY_2;
        case 4:
            return KEY_3;
        case 5:
            return KEY_4;
        case 6:
            return KEY_5;
        case 7:
            return KEY_6;
        case 8:
            return KEY_7;
        case 9:
            return KEY_8;
        case 10:
            return KEY_9;
        case 11:
            return KEY_0;
        case 28:
            return KEY_ENTER;
        case 1:
            return KEY_ESCAPE;
        case 14:
            return KEY_BACKSPACE;
        case 15:
            return KEY_TAB;
        case 57:
            return KEY_SPACE;
        case 12:
            return KEY_MINUS;
        case 13:
            return KEY_EQUAL;
        case 26:
            return KEY_LBRACE;
        case 27:
            return KEY_RBRACE;
        case 43:
            return KEY_BACKSLASH;
        case 39:
            return KEY_SEMICOLON;
        case 40:
            return KEY_APOSTROPHE;
        case 41:
            return KEY_GRAVEACCENT;
        case 51:
            return KEY_COMMA;
        case 52:
            return KEY_PERIOD;
        case 53:
            return KEY_SLASH;
        case 58:
            return KEY_CAPSLOCK;
        case 59:
            return KEY_F1;
        case 60:
            return KEY_F2;
        case 61:
            return KEY_F3;
        case 62:
            return KEY_F4;
        case 63:
            return KEY_F5;
        case 64:
            return KEY_F6;
        case 65:
            return KEY_F7;
        case 66:
            return KEY_F8;
        case 67:
            return KEY_F9;
        case 68:
            return KEY_F10;
        case 87:
            return KEY_F11;
        case 88:
            return KEY_F12;
        case 106:
            return KEY_RIGHT;
        case 105:
            return KEY_LEFT;
        case 108:
            return KEY_DOWN;
        case 103:
            return KEY_UP;
        case 29:
            return KEY_LCONTROL;
        case 42:
            return KEY_LSHIFT;
        case 56:
            return KEY_LALT;
        case 125:
            return KEY_LMETA;
        case 97:
            return KEY_RCONTROL;
        case 54:
            return KEY_RSHIFT;
        case 100:
            return KEY_RALT;
        case 126:
            return KEY_RMETA;
        case 272:
            return MOUSE_BUTTON_LEFT;
        case 274:
            return MOUSE_BUTTON_MIDDLE;
        case 273:
            return MOUSE_BUTTON_RIGHT;
        default:
            return KEY_NONE;
    }
}
#endif  // WINDOW_BACKEND_LINUX
