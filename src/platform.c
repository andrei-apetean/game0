#include "platform.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "common.h"

typedef struct internal_state internal_state;

typedef struct platform_state {
    bool (*startup)(internal_state*);
    bool (*shutdown)(internal_state*);
    bool (*update)(internal_state*);
    bool (*is_running)(internal_state*);
    bool (*poll_events)(internal_state*);
    bool (*get_window_surface)(internal_state*, win_surface*);
    internal_state* internal_state;
} platform_state;

#ifdef OS_LINUX

//
//  Wayland Implementation /////////////////////////////////////////////////////////
//
#include <wayland-client-core.h>
#include <wayland-client-protocol.h>
#include <wayland-client.h>  //libwayland-protocols
#include <xdg-shell.h>       //generated by wayland-scanner

#include <xdg-shell.c>  //todo: build and link
#define WIDTH 1920
#define HEIGHT 1080

#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

typedef struct win_surface {
    struct wl_surface* surface;
    struct wl_display* display;
} win_surface;

typedef struct internal_state_wl {
    struct wl_registry*   registry;
    struct wl_compositor* compositor;
    struct xdg_wm_base*   shell;
    struct xdg_surface*   xdg_surface;
    struct xdg_toplevel*  toplevel;
    win_surface           win;
    bool                  is_running;

    struct wl_shm*      shm;
    struct wl_shm_pool* pool;
    struct wl_buffer*   buffer;
} internal_state_wl;

int create_shm_file(size_t size) {
    int fd = shm_open("/shm-buffer", O_RDWR | O_CREAT, 0600);
    if (fd < 0) return -1;
    if (ftruncate(fd, size) < 0) {
        close(fd);
        return -1;
    }
    return fd;
}
void create_shm_buffer(internal_state_wl* state) {
    int stride = WIDTH * 4;
    int size = stride * HEIGHT;

    int fd = create_shm_file(size);
    if (fd < 0) {
        printf("Failed to create SHM file\n");
        exit(1);
    }

    void* data = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (data == MAP_FAILED) {
        printf("Failed to mmap\n");
        exit(1);
    }

    memset(data, 81, size);  // Fill buffer with white pixels

    state->pool = wl_shm_create_pool(state->shm, fd, size);
    state->buffer = wl_shm_pool_create_buffer(state->pool, 0, WIDTH, HEIGHT,
                                              stride, WL_SHM_FORMAT_XRGB8888);

    close(fd);
}
static void handle_shell_configure(void*               data,
                                   struct xdg_surface* shell_surface,
                                   uint32_t            serial) {
    xdg_surface_ack_configure(shell_surface, serial);
    //    if (resize)
    //    {
    //        readyToResize = 1;
    //    }
}

static const struct xdg_surface_listener shell_surface_listener = {
    .configure = handle_shell_configure,
};

static void handle_shell_ping(void* data, struct xdg_wm_base* xdg_wm_base,
                              uint32_t serial) {
    xdg_wm_base_pong(xdg_wm_base, serial);
}

static struct xdg_wm_base_listener shell_listener = {
    .ping = handle_shell_ping,
};

static void handle_registry(void* data, struct wl_registry* registry,
                            uint32_t name, const char* interface,
                            uint32_t version) {
    internal_state_wl* state = data;
    if (strcmp(interface, wl_compositor_interface.name) == 0) {
        state->compositor = wl_registry_bind(state->registry, name,
                                             &wl_compositor_interface, 1);
    } else if (strcmp(interface, xdg_wm_base_interface.name) == 0) {
        state->shell =
            wl_registry_bind(registry, name, &xdg_wm_base_interface, 1);
        xdg_wm_base_add_listener(state->shell, &shell_listener, NULL);
    } else if (strcmp(interface, "wl_shm") == 0) {
        state->shm = wl_registry_bind(registry, name, &wl_shm_interface, 1);
    }
}

static const struct wl_registry_listener registry_listener = {
    .global = handle_registry,
};

static void handle_toplevel_configure(void* data, struct xdg_toplevel* toplevel,
                                      int32_t width, int32_t height,
                                      struct wl_array* states) {
    // if (width != 0 && height != 0) {
    //     platform.width = width;
    //     platform.height = height;
    // }
}

static void handle_toplevel_close(void* data, struct xdg_toplevel* toplevel) {
    printf("Close requested!\n");
    internal_state_wl* state = data;
    if (state != NULL) {
        state->is_running = false;
    }
}

static const struct xdg_toplevel_listener toplevel_listener = {
    .configure = handle_toplevel_configure,
    .close = handle_toplevel_close,
};

bool platform_startup_wl(internal_state* state) {
    internal_state_wl* state_wl = (internal_state_wl*)state;
    if (state_wl == NULL) {
        printf("Platform state is invaid!\n");
        return NULL;
    }

    state_wl->win.display = wl_display_connect(NULL);
    if (state_wl->win.display == NULL) {
        printf("Failed to connect wl_display!\n");
        return false;
    }

    state_wl->registry = wl_display_get_registry(state_wl->win.display);
    if (state_wl->registry == NULL) {
        printf("Failed to get wayland registry!\n");
        return false;
    }
    wl_registry_add_listener(state_wl->registry, &registry_listener, state_wl);
    wl_display_roundtrip(state_wl->win.display);

    if (state_wl->compositor == NULL) {
        printf("Cannot open window - compositor is not initialized!");
        return false;
    }
    state_wl->win.surface = wl_compositor_create_surface(state_wl->compositor);
    if (state_wl->win.surface == NULL) {
        printf("Failed to create wayland surface!\n");
        return false;
    }

    state_wl->xdg_surface =
        xdg_wm_base_get_xdg_surface(state_wl->shell, state_wl->win.surface);
    if (state_wl->xdg_surface == NULL) {
        printf("Failed to get xdg_surface!\n");
        return false;
    }
    xdg_surface_add_listener(state_wl->xdg_surface, &shell_surface_listener,
                             NULL);

    state_wl->toplevel = xdg_surface_get_toplevel(state_wl->xdg_surface);
    if (state_wl->toplevel == NULL) {
        printf("Failed to get xdg_toplevel!\n");
        return false;
    }
    xdg_toplevel_add_listener(state_wl->toplevel, &toplevel_listener, state_wl);

    xdg_toplevel_set_title(state_wl->toplevel, "game0");

    create_shm_buffer(state_wl);
    // Commit the surface to display
    wl_surface_commit(state_wl->win.surface);
    wl_display_roundtrip(state_wl->win.display);

    printf("Platform startup successful!\n");
    state_wl->is_running = true;
    return state_wl;
}

bool platform_shutdown_wl(internal_state* state) {
    internal_state_wl* state_wl = (internal_state_wl*)state;
    if (state_wl == NULL) {
        printf("Cannot shutdown platform - state is invalid!\n");
        return false;
    }

    xdg_toplevel_destroy(state_wl->toplevel);
    xdg_surface_destroy(state_wl->xdg_surface);
    wl_surface_destroy(state_wl->win.surface);
    xdg_wm_base_destroy(state_wl->shell);
    wl_compositor_destroy(state_wl->compositor);
    wl_registry_destroy(state_wl->registry);
    wl_display_disconnect(state_wl->win.display);

    printf("Platform shutdown successful!\n");
    return true;
}

bool platform_poll_events_wl(internal_state* state) {
    internal_state_wl* state_wl = (internal_state_wl*)state;
    if (state_wl == NULL || state_wl->win.display == NULL) {
        printf("Cannot poll platform events - platform state is invalid!\n");
        return false;
    }
    int32_t result = wl_display_dispatch_pending(state_wl->win.display);
    if (result < 0) {
        return false;
    }
    return true;
}

bool platform_get_window_surface_wl(internal_state* state, win_surface* win) {
    internal_state_wl* state_wl = (internal_state_wl*)state;
    if (state_wl == NULL) {
        printf("Cannot retrieve window surface - state is invalid!\n");
        return false;
    }
    win = &state_wl->win;
    return true;
}

bool platform_update_wl(internal_state* state) {
    internal_state_wl* state_wl = (internal_state_wl*)state;
    if (state_wl == NULL) {
        printf("Cannot run platform update - state is invalid!\n");
        return NULL;
    }

    wl_surface_attach(state_wl->win.surface, state_wl->buffer, 0, 0);
    wl_surface_commit(state_wl->win.surface);

    wl_display_roundtrip(state_wl->win.display);
    return true;
}

bool platform_is_running_wl(internal_state* state) {
    internal_state_wl* state_wl = (internal_state_wl*)state;
    return state_wl != NULL && state_wl->is_running;
}
#endif  // OS_LINUX

size_t platform_get_size() {
    size_t interface_size = sizeof(platform_state);

#ifdef OS_LINUX
    return interface_size + sizeof(internal_state_wl);
#else
    return 0;
#endif  // OS_LINUX
}

bool platform_startup(platform_state* state) {
    if (state == NULL) {
        printf("Cannot startup platform - state is invalid!\n");
    }
#ifdef OS_LINUX
    state->startup = platform_startup_wl;
    state->shutdown = platform_shutdown_wl;
    state->update = platform_update_wl;
    state->poll_events = platform_poll_events_wl;
    state->is_running = platform_is_running_wl;
    state->get_window_surface = platform_get_window_surface_wl;
    state->internal_state = (internal_state*)(state + sizeof(platform_state));

    return state->startup(state->internal_state);
#else
    printf("Cannot startup platform - only wayland backend is implemented!\n");
    return false;
#endif  // OS_LINUX
}



//
//  PLatform Interface /////////////////////////////////////////////////////////
//

bool platform_shutdown(platform_state* state) {
    if (state == NULL) {
        return false;
    }
    return state->shutdown(state->internal_state);
}

bool platform_update(platform_state* state) {
    if (state == NULL) {
        return false;
    }
    return state->update(state->internal_state);
}

bool platform_is_running(platform_state* state) {
    if (state == NULL) {
        return false;
    }
    return state->is_running(state->internal_state);
}

bool platform_poll_events(platform_state* state) {
    if (state == NULL) {
        return false;
    }
    return state->poll_events(state->internal_state);
}

bool platform_get_window_surface(platform_state* state, win_surface* surface) {
    if (state == NULL) {
        return false;
    }
    return state->get_window_surface(state->internal_state, surface);
}
